\chapter{Data Locality in Task Models}
\label{ch:taskmodels}


%Define your Area
%  Create definition of your research area
%  Describe key concepts that define your area or that were uncovered during the course of conversation
%  A few examples of work in that area (can refer back to talks on website, but no need to recount entire talk)

%Findings:
%‚ñ† Describe points/observations/discoveries/challenges/issues uncovered in the session
 %‚óè Distill into summary (major discoveries)
 %‚óè can refer back to presentations for details
 %‚óè Can also use data from panel discussions
%‚ñ† Identify areas of agreement
 %‚óè Common approaches
 %‚óè Common concerns
%‚ñ† Identify areas of disagreement
 %‚óè what is the substantive cause of the disagreement (document)
 %‚óè What metrics/information/research are needed to compare/resolve
%‚ñ† Identify Gaps
 %‚óè What is missing?

%Recommendations
%‚ñ† Opportunities for standardization of mature technologies where the is substantial agreement or commonality
 %‚óè Have we met the necessary conditions for standardization (is the area well enough understood, are the elements of existing implementations sufficiently similar, are the benefits clearly demonstrated, is there a user community?)
 %‚óè What should we standardize? ( Low¬≠hanging fruit )
 %‚óè How can we influence standards committees? (e.g. C++17standards committee?)
%‚ñ† Define research agenda for new ideas or areas where there is insufficient information to choose a final implementation ( What areas need more research?)
 %‚óè identify research thrust
 %‚óè what are the opportunities
 %‚óè what needs to be done
 %‚óè What needs to be prioritized?
 %‚óè What resources would be required (estimate size/complexity ofthe problem if you can)
%‚ñ† How do we create a user community? (bonus question)


HIGHLIGHTS

\begin{itemize}
	
	
	\item SCOPE
	\begin{itemize}
		\item Design of interfaces to express
		      locality in a task-based programming model
		\item Terminology: ``task-based'', ``interfaces'' (mostly to specify the levels of the interfaces)
		\item task-based parallelism is the way to go for many applications (MPI+Task)
		\item Fast prototyping
		\item Redesigning numerical algorithms to express locality 
		and how to express it (nested parallelism, divide and conquer, tree structure)
		\item Interface betw app/rt/hw to support locality
		\item Specific performance/debugging tools for task-based applications
		\item Compiler technology RT Vs Library RT
	\end{itemize}
	
	
	
	\item RELATED WORK: a few examples of work in that area 
	\begin{itemize}
		\item OmpSs
		\item Charm++
		\item QUARK
		\item StarPU
		\item PaRSEC
		\item SuperMatrix
		\item ParalleX
		\item OCR
	\end{itemize}



	\item DISCOVERIES/CHALLENGES
	\begin{itemize}
		\item Task granularity (flexibility)
		\item Scheduling overhead
		\item Efficient debugging/tracing mechanisms/tools
		\item Nested parallelism (recursive formulation)
		\item Work stealing
		\item Scheduling priority
		\item Socket-aware scheduling
		\item Detection of overlapped memory-region
		\item API Standardization
	\end{itemize}
			
			
			
	\item AREAS OF AGREEMENT
		  \begin{itemize}
		  \item Static partitioning does not work for everything; we need to
		      have a dynamic component.
		  \item A perfectly predictable hardware does not exist and, in the
		      future will be even more far-fetched; we therefore cannot get
		      away from some level of dynamism and task-based
		      programming-models can make better use of this dynamism.
		  \item Granularity is a key issue that needs to be addressed with
		      respect to locality. There is agreement that a static
		      partitioning/granularity will not work for future
		      machines. Granularity needs to balance overheads and exposing
		      parallelism.
		  \end{itemize}
	
	
	
	\item AREAS OF DISAGREEMENT
		  \begin{itemize}
		  \item The level at which standardization should be done: task-based
		      runtime API, languages, interface to hardware, ...
		  \item What/who should have control of the granularity and how should
		      it be expressed (is it easier to break-down or recompose?)
		  \end{itemize}


	\item Identify Gaps / What is missing
	    \begin{itemize}
		
		\item Better understanding of the performance features of task-parallel
		systems. Need to convince developers of the value of these systems. 
		\begin{itemize}
		  \item Better performance tools. Better understanding of the impact of locality
		  \item Case studies that show performance benefit in certain conditions (eg,
		    in the presence of faults?). Focus on data aspects, i.e. show that
		a good management can be done even when there are a lot of work steals. 
	      \end{itemize}  
	  \end{itemize}  

	\item APPLICATION DOMAINS
		\begin{itemize}
			\item Dense linear algebra
			\item Computational astronomy
			\item Uncertainty Quantification
			\item Seismic
			\item Weather/Climate modeling
			\item Krylov-based solvers
			\item Nbody problems
		\end{itemize}

\end{itemize}


