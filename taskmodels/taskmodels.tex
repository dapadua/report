\chapter{Data Locality in Task Models}
\label{ch:taskmodels}


%Define your Area
%  Create definition of your research area
%  Describe key concepts that define your area or that were uncovered during the course of conversation
%  A few examples of work in that area (can refer back to talks on website, but no need to recount entire talk)

%Findings:
%■ Describe points/observations/discoveries/challenges/issues uncovered in the session
 %● Distill into summary (major discoveries)
 %● can refer back to presentations for details
 %● Can also use data from panel discussions
%■ Identify areas of agreement
 %● Common approaches
 %● Common concerns
%■ Identify areas of disagreement
 %● what is the substantive cause of the disagreement (document)
 %● What metrics/information/research are needed to compare/resolve
%■ Identify Gaps
 %● What is missing?

%Recommendations
%■ Opportunities for standardization of mature technologies where the is substantial agreement or commonality
 %● Have we met the necessary conditions for standardization (is the area well enough understood, are the elements of existing implementations sufficiently similar, are the benefits clearly demonstrated, is there a user community?)
 %● What should we standardize? ( Low­hanging fruit )
 %● How can we influence standards committees? (e.g. C++17standards committee?)
%■ Define research agenda for new ideas or areas where there is insufficient information to choose a final implementation ( What areas need more research?)
 %● identify research thrust
 %● what are the opportunities
 %● what needs to be done
 %● What needs to be prioritized?
 %● What resources would be required (estimate size/complexity ofthe problem if you can)
%■ How do we create a user community? (bonus question)


HIGHLIGHTS

\begin{itemize}
	
	
	\item SCOPE
	\begin{itemize}
		\item Design of interfaces to express
		      locality in a task-based programming model
		\item Terminology: ``task-based'', ``interfaces'' (mostly to specify the levels of the interfaces)
		\item task-based parallelism is the way to go for many applications (MPI+Task)
		\item Fast prototyping
		\item Redesigning numerical algorithms to express locality 
		and how to express it (nested parallelism, divide and conquer, tree structure)
		\item Interface betw app/rt/hw to support locality
		\item Specific performance/debugging tools for task-based applications
		\item Compiler technology RT Vs Library RT
	\end{itemize}
	
	
	
	\item RELATED WORK: a few examples of work in that area 
	\begin{itemize}
		\item OmpSs
		\item Charm++
		\item QUARK
		\item StarPU
		\item PaRSEC
		\item SuperMatrix
		\item ParalleX
		\item OCR
	\end{itemize}



	\item DISCOVERIES/CHALLENGES
	\begin{itemize}
		\item Task granularity (flexibility)
		\item Scheduling overhead
		\item Efficient debugging/tracing mechanisms/tools
		\item Nested parallelism (recursive formulation)
		\item Work stealing
		\item Scheduling priority
		\item Socket-aware scheduling
		\item Detection of overlapped memory-region
		\item API Standardization
	\end{itemize}
			
			
			
	\item AREAS OF AGREEMENT
		  \begin{itemize}
		  \item Static partitioning does not work for everything; we need to
		      have a dynamic component.
		  \item A perfectly predictable hardware does not exist and, in the
		      future will be even more far-fetched; we therefore cannot get
		      away from some level of dynamism and task-based
		      programming-models can make better use of this dynamism.
		  \item Granularity is a key issue that needs to be addressed with
		      respect to locality. There is agreement that a static
		      partitioning/granularity will not work for future
		      machines. Granularity needs to balance overheads and exposing
		      parallelism.
		  \end{itemize}
	
	
	
	\item AREAS OF DISAGREEMENT
		  \begin{itemize}
		  \item The level at which standardization should be done: task-based
		      runtime API, languages, interface to hardware, ...
		  \item What/who should have control of the granularity and how should
		      it be expressed (is it easier to break-down or recompose?)
		  \end{itemize}



	\item APPLICATION DOMAINS
		\begin{itemize}
			\item Dense linear algebra
			\item Computational astronomy
			\item Uncertainty Quantification
			\item Seismic
			\item Weather/Climate modeling
			\item Krylov-based solvers
			\item Nbody problems
		\end{itemize}

\end{itemize}
