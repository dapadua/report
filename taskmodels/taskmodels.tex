\chapter{Data Locality in Task Models}
\label{ch:taskmodels}


%Define your Area
%  Create definition of your research area
%  Describe key concepts that define your area or that were uncovered during the course of conversation
%  A few examples of work in that area (can refer back to talks on website, but no need to recount entire talk)

%Findings:
%‚ñ† Describe points/observations/discoveries/challenges/issues uncovered in the session
 %‚óè Distill into summary (major discoveries)
 %‚óè can refer back to presentations for details
 %‚óè Can also use data from panel discussions
%‚ñ† Identify areas of agreement
 %‚óè Common approaches
 %‚óè Common concerns
%‚ñ† Identify areas of disagreement
 %‚óè what is the substantive cause of the disagreement (document)
 %‚óè What metrics/information/research are needed to compare/resolve
%‚ñ† Identify Gaps
 %‚óè What is missing?

%Recommendations
%‚ñ† Opportunities for standardization of mature technologies where the is substantial agreement or commonality
 %‚óè Have we met the necessary conditions for standardization (is the area well enough understood, are the elements of existing implementations sufficiently similar, are the benefits clearly demonstrated, is there a user community?)
 %‚óè What should we standardize? ( Low¬≠hanging fruit )
 %‚óè How can we influence standards committees? (e.g. C++17standards committee?)
%‚ñ† Define research agenda for new ideas or areas where there is insufficient information to choose a final implementation ( What areas need more research?)
 %‚óè identify research thrust
 %‚óè what are the opportunities
 %‚óè what needs to be done
 %‚óè What needs to be prioritized?
 %‚óè What resources would be required (estimate size/complexity ofthe problem if you can)
%‚ñ† How do we create a user community? (bonus question)


HIGHLIGHTS

\begin{itemize}


	\item SCOPE (\textbf{Jesus})
	\begin{itemize}
		\item Design of interfaces to express
		      locality in a task-based programming model
		\item Terminology: ``task-based'', ``interfaces'' (mostly to specify the levels of the interfaces)
		\item task-based parallelism is the way to go for many applications (MPI+Task)
		\item Fast prototyping / productivity
		\item Redesigning numerical algorithms to express locality
		and how to express it (nested parallelism, divide and conquer, tree structure)
		\item Interface betw app/rt/hw to support locality
		\item Specific performance/debugging tools for task-based applications
		\item Compiler technology RT Vs Library RT
	\end{itemize}



	\item RELATED WORK: a few examples of work in that area  (\textbf{Hatem})
	\begin{itemize}
		\item OmpSs
		\item Charm++
		\item QUARK
		\item StarPU
		\item PaRSEC
		\item SuperMatrix
		\item ParalleX
		\item OCR
	\end{itemize}



	\item DISCOVERIES/CHALLENGES
	\begin{itemize}
		\item Task granularity (flexibility) (\textbf{Miquel})
		\item Scheduling overhead (\textbf{Miquel})
		\item Efficient debugging/tracing mechanisms/tools (\textbf{Jesus})
		\item Nested parallelism (recursive formulation) (\textbf{Hatem})
		\item Work stealing (\textbf{Miquel})
		\item Scheduling priority, DAG critical path  (\textbf{Romain})
		\item Socket-aware scheduling (\textbf{Hatem})
		\item Detection of overlapped memory-region (\textbf{Jesus})
		\item API Standardization (\textbf{Romain})
		\item DAG Composition (\textbf{Hatem})
		\item Handling data locality in presence of co-processors and accelerators (\textbf{Jesus})
	\end{itemize}



	\item AREAS OF AGREEMENT (\textbf{Romain})
          \begin{itemize}
          \item{
              The performance and energy characteristics of today's
hardware are difficult to predict; the unpredictability of a hit or
miss in a cache, the variable latencies introduced by branch
mis-predictions, etc.\ are only some of the factors that contribute to
a very dynamic hardware behavior. This trend will only accelerate with
future hardware as near threshold voltage (NTV) and aggressive energy
management increase the level of hardware dynamism. [TODO: Maybe
phrase it to say that the assembly interface does not guarantee
anything in terms of performance and/or energy].

              In light of this, toolchains will become more and more
unable to statically partition and schedule code to efficiently
utilize future parallel resources. Hardware characteristics will vary
dynamically and we therefore cannot do without a dose of dynamism in
the programming model: dynamic task based programming models need to
be a part of the solution.
            }
          \item{
              Task base programming models, however, rely on the
computation and data being split into chunks (``tasks'' for the
computation which implies a size of the data these tasks operate
on). The size of these chunks (the granularity) is difficult to
determine as it needs to balance the overheads of the task-based
system with the need to expose sufficient parallelism to fully occupy
the ever increasing number of parallel resources. A static granularity
will be sub-optimal for future machines [TODO: Do I need to add more
to this]
            }
          \end{itemize}
% OLD STUFF
		  % \begin{itemize}
		  % \item Static partitioning does not work for everything; we need to
		  %     have a dynamic component.
		  % \item A perfectly predictable hardware does not exist and, in the
		  %     future will be even more far-fetched; we therefore cannot get
		  %     away from some level of dynamism and task-based
		  %     programming-models can make better use of this dynamism.
		  % \item Granularity is a key issue that needs to be addressed with
		  %     respect to locality. There is agreement that a static
		  %     partitioning/granularity will not work for future
		  %     machines. Granularity needs to balance overheads and exposing
		  %     parallelism.
		  % \end{itemize}



	\item AREAS OF DISAGREEMENT (\textbf{Romain})
          \begin{itemize}
            \item{
                There is agreement on the fact that a standardization
needs to happen for task based programming model but there is
disagreement as to the level at which this standardization needs to
happen. One option is to standardize the APIs at the runtime level in
a way similar to the Open Community Runtime (OCR). Another option is
to standardize what can be expressed by the user at the programming
model level [TODO: Jesus, I would like to understand your position a
bit more on this so I can clarify things a bit more].
              }
            \item{
                Another area of disagreement is how best to deal with
 the expression of granularity; specifically, is it better for the
 programmer to break-down tasks and data and have a runtime system
 re-assemble them if needed or is it preferable to have the programmer
express coarse grained tasks and data and allow the runtime system to
break them down further. The latter approach has been used
successfully in runtimes targetted to problems that are recursively
divisible. The former approach would require a sort of ``recipe'' for
the runtime to be able to stich smaller tasks or chunks of data into
larger ones. There is debate as to which approach is simpler and more
likely to yield positive results.
              }
            \end{itemize}

% OLD STUFF
		  % \begin{itemize}
		  % \item The level at which standardization should be done: task-based
		  %     runtime API, languages, interface to hardware, ...
		  % \item What/who should have control of the granularity and how should
		  %     it be expressed (is it easier to break-down or recompose?)
		  % \end{itemize}


	\item Identify Gaps / What is missing  (\textbf{Miquel})
	    \begin{itemize}
		\item Better understanding of the performance features of task-parallel
		systems. Need to convince developers of the value of these systems.
		\begin{itemize}
		  \item Better performance tools. Better understanding of the impact of locality
		  \item Case studies that show performance benefit in certain conditions (eg,
		    in the presence of faults?). Focus on data aspects, i.e. show that
		a good management can be done even when there are a lot of work steals.
	      \end{itemize}
	  \end{itemize}


	\item APPLICATION DOMAINS  (\textbf{Hatem})
		\begin{itemize}
			\item Dense linear algebra
			\item Computational astronomy
			\item Uncertainty Quantification
			\item Seismic
			\item Weather/Climate modeling
			\item Krylov-based solvers
			\item Nbody problems
		\end{itemize}

\end{itemize}
